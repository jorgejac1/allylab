import { describe, it, expect, vi, beforeEach } from "vitest";
import type jsPDF from "jspdf";
import {
  hexToRgb,
  truncateText,
  createPageBreakChecker,
  addPdfFooter,
  addPdfHeader,
  drawTableHeader,
  drawTableRow,
} from "../../utils/pdf/pdfUtils";

// Create mock PDF object factory
function createMockPdf() {
  return {
    internal: {
      pageSize: {
        getWidth: () => 210,
        getHeight: () => 297,
      },
      pages: [null, {}, {}], // 2 pages
    },
    addPage: vi.fn(),
    setPage: vi.fn(),
    setFontSize: vi.fn(),
    setFont: vi.fn(),
    setTextColor: vi.fn(),
    setFillColor: vi.fn(),
    text: vi.fn(),
    rect: vi.fn(),
  } as unknown as jsPDF;
}

describe("utils/pdfUtils", () => {
  describe("hexToRgb", () => {
    it("converts valid hex color to RGB", () => {
      expect(hexToRgb("#ff5733")).toEqual({ r: 255, g: 87, b: 51 });
    });

    it("converts hex without # prefix", () => {
      expect(hexToRgb("00ff00")).toEqual({ r: 0, g: 255, b: 0 });
    });

    it("returns black for invalid hex", () => {
      expect(hexToRgb("invalid")).toEqual({ r: 0, g: 0, b: 0 });
    });

    it("converts white correctly", () => {
      expect(hexToRgb("#ffffff")).toEqual({ r: 255, g: 255, b: 255 });
    });

    it("converts black correctly", () => {
      expect(hexToRgb("#000000")).toEqual({ r: 0, g: 0, b: 0 });
    });
  });

  describe("truncateText", () => {
    it("returns unchanged text if within limit", () => {
      expect(truncateText("short", 10)).toBe("short");
    });

    it("truncates long text with ellipsis", () => {
      expect(truncateText("this is a very long text", 10)).toBe("this is...");
    });

    it("handles exact length", () => {
      expect(truncateText("exact", 5)).toBe("exact");
    });

    it("truncates at maxLength - 3 for ellipsis", () => {
      expect(truncateText("1234567890", 8)).toBe("12345...");
    });
  });

  describe("createPageBreakChecker", () => {
    let pdf: jsPDF;
    let yPosition: number;

    beforeEach(() => {
      pdf = createMockPdf();
      yPosition = 250;
    });

    it("returns false when content fits on page", () => {
      const checkPageBreak = createPageBreakChecker(
        pdf,
        20,
        () => yPosition,
        (y) => {
          yPosition = y;
        }
      );

      expect(checkPageBreak(20)).toBe(false);
      expect(yPosition).toBe(250);
    });

    it("adds page and resets position when content exceeds page", () => {
      const checkPageBreak = createPageBreakChecker(
        pdf,
        20,
        () => yPosition,
        (y) => {
          yPosition = y;
        }
      );

      expect(checkPageBreak(50)).toBe(true);
      expect(pdf.addPage).toHaveBeenCalled();
      expect(yPosition).toBe(20); // Reset to margin
    });
  });

  describe("addPdfFooter", () => {
    it("adds footer to all pages", () => {
      const pdf = createMockPdf();
      addPdfFooter(pdf, 20);

      // Should set page for each page
      expect(pdf.setPage).toHaveBeenCalledWith(1);
      expect(pdf.setPage).toHaveBeenCalledWith(2);

      // Should add page numbers and branding
      expect(pdf.text).toHaveBeenCalledWith(
        "Page 1 of 2",
        expect.any(Number),
        expect.any(Number),
        { align: "center" }
      );
      expect(pdf.text).toHaveBeenCalledWith(
        "Generated by AllyLab",
        expect.any(Number),
        expect.any(Number),
        { align: "right" }
      );
    });
  });

  describe("addPdfHeader", () => {
    it("adds header with company name and title", () => {
      const pdf = createMockPdf();
      const yPos = addPdfHeader(pdf, 20, "Test Company", "Report Title");

      expect(pdf.setFontSize).toHaveBeenCalledWith(24);
      expect(pdf.text).toHaveBeenCalledWith("Test Company", 20, 20);
      expect(pdf.text).toHaveBeenCalledWith("Report Title", 20, 30);
      expect(yPos).toBe(45); // margin + 10 + 8 + 7
    });

    it("adds subtitle when provided", () => {
      const pdf = createMockPdf();
      const yPos = addPdfHeader(pdf, 20, "Company", "Title", "Subtitle");

      expect(pdf.text).toHaveBeenCalledWith("Subtitle", 20, 38);
      expect(yPos).toBe(53); // margin + 10 + 8 + 15
    });
  });

  describe("drawTableHeader", () => {
    it("draws table header row", () => {
      const pdf = createMockPdf();
      const columns = [
        { header: "Name", width: 50 },
        { header: "Value", width: 30 },
      ];

      drawTableHeader(pdf, columns, 20, 100);

      expect(pdf.setFillColor).toHaveBeenCalledWith(241, 245, 249);
      expect(pdf.rect).toHaveBeenCalled();
      expect(pdf.text).toHaveBeenCalledWith("Name", 22, 100);
      expect(pdf.text).toHaveBeenCalledWith("Value", 72, 100);
    });
  });

  describe("drawTableRow", () => {
    it("draws normal row", () => {
      const pdf = createMockPdf();
      const data = ["Cell1", "Cell2"];
      const widths = [50, 30];

      drawTableRow(pdf, data, widths, 20, 100, false);

      expect(pdf.text).toHaveBeenCalledWith("Cell1", 22, 100);
      expect(pdf.text).toHaveBeenCalledWith("Cell2", 72, 100);
    });

    it("draws alternate row with background", () => {
      const pdf = createMockPdf();
      const data = ["Cell1", "Cell2"];
      const widths = [50, 30];

      drawTableRow(pdf, data, widths, 20, 100, true);

      expect(pdf.setFillColor).toHaveBeenCalledWith(248, 250, 252);
      expect(pdf.rect).toHaveBeenCalled();
    });
  });
});
